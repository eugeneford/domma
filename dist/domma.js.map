{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap c2046a51b07375054298","webpack:///external \"anodum\"","webpack:///./src/domma.js","webpack:///./src/mutation-driver.js","webpack:///./src/mutation-types.js","webpack:///./src/reference-map.js"],"names":["Domma","options","config","childList","attributes","attributeOldValue","characterData","characterDataOldValue","subtree","reset","staticDOM","driver","connectStaticDocument","getStaticDocument","ReferenceError","liveDOM","referenceMap","composeLiveReference","connectLiveDocument","mutationObserver","disconnect","observe","getLiveDocument","transactionStatus","transaction","Promise","resolve","reject","then","element","refElement","position","insertAdjacentElement","removeElement","preserveFilter","synchronizeElement","transactionObserver","MutationObserver","conductTransaction","mutationEmitter","mutations","isTransactionPending","addAdditiveMutations","MutationDriver","onBeforeSync","onAfterSync","additiveMutations","bind","conductMutation","reduceAdditiveMutations","TypeError","liveElement","containerNode","getReference","unbind","mutation","attributeName","oldValue","containerId","getReferenceId","setReferenceAttribute","removeReferenceAttribute","liveNode","isAdditiveNode","liveParent","parentNode","liveNodeIndex","Array","prototype","slice","call","childNodes","indexOf","staticParent","staticNode","nodeValue","addedNodes","removedNodes","nextLiveSibling","nextSibling","length","previousSibling","node","nextStaticSibling","liveNodes","liveIndex","prevLiveSibling","prevStaticSibling","forEach","addedLiveNode","id","removeReference","firstChild","removeChild","removedLiveNode","cloneNode","textMutations","getAdditiveMutations","textMutation","insertBefore","appendChild","lNode","ejectAdditiveReferenceMapMutations","reverse","type","ejectAdditiveAttributeMutation","ejectAdditiveChildListMutation","filteredMutations","filter","refAttribute","referenceAttribute","concat","types","all","index","splice","sameTarget","target","validType","some","isAdditive","isChildOfAdditive","reference","referenceId","attribute","hasAttribute","value","getAttribute","newReference","replaceReference","ejectAdditiveMutations","flush","hasReference","conductAttributeMutation","conductCharacterDataMutation","conductChildListMutation","liveRefElement","refElementId","insertReference","elementId","shouldPreserve","ejectAdditiveCharacterDataMutation","ReferenceMap","forEachReferenceSave","map","referenceCounter","staticDocument","setAttribute","importNode","rootPath","removeAttribute","path","sNode","saveReference","staticRoot","ownerDocument","Object","hasOwnProperty","undefined","previousElementSibling","nextElementSibling","parentElement","firstElementChild","lastElementChild","childIndex","getReferenceById","nodesList","isReferenceId","attr","staticContainer","composeStaticReference","oldStaticElement","newStaticElement","replaceChild","keys"],"mappings":"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","file":"./dist/domma.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"anodum\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"anodum\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"domma\"] = factory(require(\"anodum\"));\n\telse\n\t\troot[\"domma\"] = factory(root[\"anodum\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c2046a51b07375054298","module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"anodum\"\n// module id = 0\n// module chunks = 0","import MutationDriver from './mutation-driver';\n\nexport default class Domma {\n  constructor(options) {\n    this.options = options;\n    this.config = {\n      childList: true,\n      attributes: true,\n      attributeOldValue: true,\n      characterData: true,\n      characterDataOldValue: true,\n      subtree: true,\n    };\n\n    this.reset();\n  }\n\n  connectStaticDocument(staticDOM) {\n    this.driver.connectStaticDocument(staticDOM);\n  }\n\n  composeLiveDocument() {\n    const staticDOM = this.driver.getStaticDocument();\n\n    if (!staticDOM) {\n      throw new ReferenceError('static document is not connected');\n    }\n\n    const liveDOM = this.driver.referenceMap.composeLiveReference(staticDOM);\n\n    this.connectLiveDocument(liveDOM);\n  }\n\n  connectLiveDocument(liveDOM) {\n    this.mutationObserver.disconnect();\n    this.driver.connectLiveDocument(liveDOM);\n    this.mutationObserver.observe(liveDOM, this.config);\n  }\n\n  getStaticDocument() {\n    return this.driver.getStaticDocument();\n  }\n\n  getLiveDocument() {\n    return this.driver.getLiveDocument();\n  }\n\n  isTransactionResolved() {\n    return this.transactionStatus === 'resolved';\n  }\n\n  isTransactionPending() {\n    return this.transactionStatus === 'pending';\n  }\n\n  conductTransaction(transaction) {\n    return new Promise((resolve, reject) => {\n      const liveDOM = this.driver.getLiveDocument();\n      if (!liveDOM) reject(new ReferenceError('live document is not connected'));\n      resolve(liveDOM);\n    }).then(liveDOM => new Promise((resolve) => {\n      this.transactionStatus = 'pending';\n      this.resolve = resolve;\n      transaction(liveDOM);\n    }));\n  }\n\n  insertAdjacentElement(element, refElement, position) {\n    return new Promise((resolve, reject) => {\n      const liveDOM = this.driver.getLiveDocument();\n      if (!liveDOM) reject(new ReferenceError('live document is not connected'));\n      resolve();\n    }).then(() => {\n      this.transactionStatus = 'pending';\n      this.driver.insertAdjacentElement(element, refElement, position);\n      this.transactionStatus = 'resolved';\n    });\n  }\n\n  removeElement(element) {\n    return new Promise((resolve, reject) => {\n      const liveDOM = this.driver.getLiveDocument();\n      if (!liveDOM) reject(new ReferenceError('live document is not connected'));\n      resolve();\n    }).then(() => {\n      this.transactionStatus = 'pending';\n      this.driver.removeElement(element);\n      this.transactionStatus = 'resolved';\n    });\n  }\n\n  synchronizeElement(element, preserveFilter) {\n    return new Promise((resolve, reject) => {\n      const liveDOM = this.driver.getLiveDocument();\n      if (!liveDOM) reject(new ReferenceError('live document is not connected'));\n      resolve();\n    }).then(() => {\n      this.driver.synchronizeElement(element, preserveFilter);\n    });\n  }\n\n  reset() {\n    if (this.transactionObserver) this.transactionObserver.disconnect();\n    if (this.mutationObserver) this.mutationObserver.disconnect();\n\n    this.driver = new MutationDriver(this.options);\n    this.transactionStatus = 'resolved';\n    this.transactionObserver = new MutationObserver(this.driver.conductTransaction);\n    this.mutationEmitter = (mutations) => {\n      if (this.isTransactionPending()) {\n        this.driver.conductTransaction(mutations);\n        this.transactionStatus = 'resolved';\n        this.resolve();\n      } else {\n        this.driver.addAdditiveMutations(mutations);\n      }\n    };\n    this.mutationObserver = new MutationObserver(this.mutationEmitter);\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/domma.js","import {\n  isDocumentNode,\n  isElementNode,\n  isChildOfElement,\n  traverseNode,\n} from 'anodum';\n\nimport mutationTypes from './mutation-types';\nimport ReferenceMap from './reference-map';\n\nexport default class MutationDriver {\n  constructor(options) {\n    this.options = {\n      onBeforeSync: () => {\n      },\n      onAfterSync: () => {\n      },\n      ...options,\n    };\n    this.additiveMutations = [];\n    this.referenceMap = new ReferenceMap(options);\n\n    this.conductTransaction = this.conductTransaction.bind(this);\n    this.conductMutation = this.conductMutation.bind(this);\n    this.reduceAdditiveMutations = this.reduceAdditiveMutations.bind(this);\n  }\n\n  connectStaticDocument(staticDOM) {\n    if (!isDocumentNode(staticDOM)) {\n      throw new TypeError('staticDOM is not a Document');\n    }\n\n    this.referenceMap.connectStaticDocument(staticDOM);\n\n    this.staticDOM = staticDOM;\n  }\n\n  connectLiveDocument(liveDOM) {\n    if (!isDocumentNode(liveDOM)) {\n      throw new TypeError('liveDOM is not a Document');\n    }\n\n    this.liveDOM = liveDOM;\n  }\n\n  getStaticDocument() {\n    return this.staticDOM;\n  }\n\n  getLiveDocument() {\n    return this.liveDOM;\n  }\n\n  ejectAdditiveReferenceMapMutations(liveElement) {\n    const containerNode = this.referenceMap.getReference(liveElement);\n    this.referenceMap.unbind(containerNode);\n  }\n\n  ejectAdditiveAttributeMutation(liveElement, mutation) {\n    const { attributeName, oldValue } = mutation;\n    const containerId = this.referenceMap.getReferenceId(liveElement);\n\n    if (oldValue) {\n      this.referenceMap.setReferenceAttribute(containerId, attributeName, oldValue);\n    } else {\n      this.referenceMap.removeReferenceAttribute(containerId, attributeName);\n    }\n  }\n\n  ejectAdditiveCharacterDataMutation(liveNode, mutation) {\n    const { oldValue } = mutation;\n\n    if (this.isAdditiveNode(liveNode)) return;\n\n    const liveParent = liveNode.parentNode;\n    const liveNodeIndex = Array.prototype.slice.call(liveParent.childNodes).indexOf(liveNode);\n    const staticParent = this.referenceMap.getReference(liveNode.parentNode);\n    const staticNode = staticParent.childNodes[liveNodeIndex];\n\n    staticNode.nodeValue = oldValue;\n  }\n\n  ejectAdditiveChildListMutation(liveElement, mutation) {\n    const containerNode = this.referenceMap.getReference(liveElement);\n    const {\n      addedNodes,\n      removedNodes,\n    } = mutation;\n\n    let nextLiveSibling = mutation.nextSibling;\n    if (removedNodes.length && addedNodes.length) {\n      nextLiveSibling = addedNodes[addedNodes.length - 1].nextSibling;\n    } else if (removedNodes.length) {\n      const { previousSibling, nextSibling } = mutation;\n      let node = nextSibling;\n      while (node) {\n        if (previousSibling === node.previousSibling) {\n          nextLiveSibling = node;\n          break;\n        }\n        node = node.previousSibling;\n      }\n    }\n\n    let nextStaticSibling;\n    if (nextLiveSibling && nextLiveSibling.parentNode) {\n      const liveNodes = Array.prototype.slice.call(nextLiveSibling.parentNode.childNodes);\n      const liveIndex = liveNodes.indexOf(nextLiveSibling);\n      nextStaticSibling = containerNode.childNodes[liveIndex];\n    }\n\n    const prevLiveSibling = mutation.previousSibling;\n\n    let prevStaticSibling;\n    if (prevLiveSibling && prevLiveSibling.parentNode) {\n      const liveNodes = Array.prototype.slice.call(prevLiveSibling.parentNode.childNodes);\n      const liveIndex = liveNodes.indexOf(prevLiveSibling);\n      prevStaticSibling = containerNode.childNodes[liveIndex];\n    }\n\n    addedNodes.forEach((addedLiveNode) => {\n      if (isElementNode(addedLiveNode)) {\n        const id = this.referenceMap.getReferenceId(addedLiveNode);\n        this.referenceMap.removeReference(id);\n        this.referenceMap.unbind(addedLiveNode);\n        this.reduceAdditiveMutations(addedLiveNode);\n      } else {\n        let staticNode;\n        if (nextStaticSibling) {\n          staticNode = nextStaticSibling.previousSibling;\n        } else if (prevStaticSibling && prevStaticSibling.nextSibling) {\n          staticNode = prevStaticSibling.nextSibling;\n        } else {\n          staticNode = containerNode.firstChild;\n        }\n        containerNode.removeChild(staticNode);\n      }\n    });\n\n    removedNodes.forEach((removedLiveNode) => {\n      let staticNode;\n      if (isElementNode(removedLiveNode)) {\n        staticNode = this.referenceMap.getReference(removedLiveNode);\n      } else {\n        staticNode = removedLiveNode.cloneNode();\n        const textMutations = this.getAdditiveMutations(removedLiveNode);\n        textMutations.forEach((textMutation) => {\n          staticNode.nodeValue = textMutation.oldValue;\n        });\n      }\n\n      if (nextStaticSibling) {\n        containerNode.insertBefore(staticNode, nextStaticSibling);\n      } else if (prevStaticSibling && prevStaticSibling.nextSibling) {\n        containerNode.insertBefore(staticNode, prevStaticSibling.nextSibling);\n      } else {\n        containerNode.appendChild(staticNode);\n      }\n    });\n  }\n\n  ejectAdditiveMutations(liveElement) {\n    traverseNode(liveElement, (lNode) => {\n      const mutations = this.getAdditiveMutations(lNode);\n\n      this.ejectAdditiveReferenceMapMutations(lNode);\n\n      mutations.reverse().forEach((mutation) => {\n        switch (mutation.type) {\n          case mutationTypes.attributes:\n            this.ejectAdditiveAttributeMutation(lNode, mutation);\n            break;\n          default:\n            this.ejectAdditiveChildListMutation(lNode, mutation);\n            break;\n        }\n      });\n    });\n  }\n\n  addAdditiveMutations(mutations) {\n    const filteredMutations = mutations.filter((mutation) => {\n      const refAttribute = this.referenceMap.options.referenceAttribute;\n      return mutation.attributeName !== refAttribute;\n    });\n\n    this.additiveMutations = this.additiveMutations.concat(filteredMutations);\n  }\n\n  reduceAdditiveMutations(liveNode, types = mutationTypes.all) {\n    const additiveMutations = this.getAdditiveMutations(liveNode, types);\n\n    additiveMutations.forEach((mutation) => {\n      const index = this.additiveMutations.indexOf(mutation);\n      this.additiveMutations.splice(index, 1);\n      mutation.addedNodes.forEach(node => this.reduceAdditiveMutations(node));\n      mutation.removedNodes.forEach(node => this.reduceAdditiveMutations(node));\n    });\n  }\n\n  getAdditiveMutations(liveNode, types = mutationTypes.all) {\n    return this.additiveMutations.filter((mutation) => {\n      const sameTarget = mutation.target === liveNode;\n      const validType = types.indexOf(mutation.type) > -1;\n      return sameTarget && validType;\n    });\n  }\n\n  hasAdditiveMutations(liveNode, types = mutationTypes.all) {\n    return this.getAdditiveMutations(liveNode, types).length > 0;\n  }\n\n  isAdditiveNode(liveNode) {\n    return this.additiveMutations.some((mutation) => {\n      if (mutation.type !== mutationTypes.childList) return false;\n      const { addedNodes } = mutation;\n      return addedNodes.some((node) => {\n        const isAdditive = node === liveNode;\n        const isChildOfAdditive = isElementNode(node) && isChildOfElement(liveNode, node);\n        return isAdditive || isChildOfAdditive;\n      });\n    });\n  }\n\n  conductAttributeMutation(mutation) {\n    const liveNode = mutation.target;\n    const reference = this.referenceMap.getReference(liveNode);\n    const referenceId = this.referenceMap.getReferenceId(liveNode);\n    const attribute = mutation.attributeName;\n\n    this.options.onBeforeSync(reference);\n    if (liveNode.hasAttribute(attribute)) {\n      const value = liveNode.getAttribute(attribute);\n      this.referenceMap.setReferenceAttribute(referenceId, attribute, value);\n    } else {\n      this.referenceMap.removeReferenceAttribute(referenceId, attribute);\n    }\n    this.options.onAfterSync(reference);\n  }\n\n  conductCharacterDataMutation(mutation) {\n    const liveNode = mutation.target.parentNode;\n    const reference = this.referenceMap.getReference(liveNode);\n    const referenceId = this.referenceMap.getReferenceId(liveNode);\n    this.reduceAdditiveMutations(mutation.target, [mutationTypes.characterData]);\n    this.options.onBeforeSync(reference);\n    const newReference = this.referenceMap.replaceReference(liveNode, referenceId);\n    this.ejectAdditiveMutations(liveNode);\n    this.referenceMap.flush();\n    this.options.onAfterSync(newReference);\n  }\n\n  conductChildListMutation(mutation) {\n    const liveNode = mutation.target;\n    const reference = this.referenceMap.getReference(liveNode);\n    const referenceId = this.referenceMap.getReferenceId(liveNode);\n    const {\n      addedNodes,\n      removedNodes,\n      nextSibling,\n      previousSibling,\n    } = mutation;\n\n    // for target.innerHTML or target.replacedChild\n    if (addedNodes.length && removedNodes.length && !nextSibling && !previousSibling) {\n      this.reduceAdditiveMutations(liveNode, [mutationTypes.childList]);\n    }\n\n    this.options.onBeforeSync(reference);\n    const newReference = this.referenceMap.replaceReference(liveNode, referenceId);\n    this.ejectAdditiveMutations(liveNode);\n    this.referenceMap.flush();\n    this.options.onAfterSync(newReference);\n  }\n\n  conductMutation(mutation) {\n    switch (mutation.type) {\n      case mutationTypes.attributes:\n        if (!this.referenceMap.hasReference(mutation.target)) return;\n        this.conductAttributeMutation(mutation);\n        break;\n      case mutationTypes.characterData:\n        if (!this.referenceMap.hasReference(mutation.target.parentNode)) return;\n        this.conductCharacterDataMutation(mutation);\n        break;\n      default:\n        if (!this.referenceMap.hasReference(mutation.target)) return;\n        this.conductChildListMutation(mutation);\n        break;\n    }\n  }\n\n  conductTransaction(mutations) {\n    mutations.forEach(this.conductMutation);\n  }\n\n  insertAdjacentElement(liveElement, liveRefElement, position) {\n    const refElementId = this.referenceMap.getReferenceId(liveRefElement);\n    this.referenceMap.insertReference(liveElement, refElementId, position);\n    liveRefElement.insertAdjacentElement(position, liveElement);\n  }\n\n  removeElement(liveElement) {\n    const elementId = this.referenceMap.getReferenceId(liveElement);\n    this.referenceMap.removeReference(elementId);\n    liveElement.parentNode.removeChild(liveElement);\n  }\n\n  synchronizeElement(liveElement, preserveFilter) {\n    const referenceId = this.referenceMap.getReferenceId(liveElement);\n    this.referenceMap.replaceReference(liveElement, referenceId);\n\n    traverseNode(liveElement, (liveNode) => {\n      const mutations = this.getAdditiveMutations(liveNode);\n\n      mutations.reverse().forEach((mutation) => {\n        const shouldPreserve = preserveFilter ? preserveFilter(mutation) : false;\n\n        if (shouldPreserve) {\n          const index = this.additiveMutations.indexOf(mutation);\n          this.additiveMutations.splice(index, 1);\n          return;\n        }\n\n        switch (mutation.type) {\n          case mutationTypes.attributes:\n            this.ejectAdditiveAttributeMutation(liveNode, mutation);\n            break;\n          case mutationTypes.characterData:\n            this.ejectAdditiveCharacterDataMutation(liveNode, mutation);\n            break;\n          default:\n            this.ejectAdditiveChildListMutation(liveNode, mutation);\n            break;\n        }\n      });\n    });\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/mutation-driver.js","export default {\n  all: ['childList', 'attributes', 'characterData'],\n  characterData: 'characterData',\n  attributes: 'attributes',\n  childList: 'childList',\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/mutation-types.js","import {\n  getNodeByTreePath,\n  getTreePathOfNode,\n  isDocumentNode,\n  isElementNode,\n  traverseNode,\n} from 'anodum';\n\n\nexport default class ReferenceMap {\n  constructor(options) {\n    this.options = {\n      referenceAttribute: 'data-uuid',\n      forEachReferenceSave: () => {\n      },\n      ...options,\n    };\n    this.map = {};\n    this.referenceCounter = 1;\n  }\n\n  connectStaticDocument(staticDocument) {\n    this.staticDocument = staticDocument;\n  }\n\n  saveReference(liveNode, staticNode, id) {\n    const referenceId = id || `ref_${this.referenceCounter}`;\n\n    if (liveNode.getAttribute(this.options.referenceAttribute) !== referenceId) {\n      liveNode.setAttribute(this.options.referenceAttribute, referenceId);\n    }\n\n    this.map[referenceId] = { staticNode };\n    this.referenceCounter += 1;\n    return referenceId;\n  }\n\n  composeStaticReference(liveNode) {\n    if (!isDocumentNode(liveNode) && !isElementNode(liveNode)) {\n      throw new TypeError('liveNode is not neither Document nor Element');\n    }\n\n    if (!this.staticDocument) {\n      throw new ReferenceError('static document is not connected');\n    }\n\n    const staticDOM = this.staticDocument;\n    const staticNode = staticDOM.importNode(liveNode, true);\n    const rootPath = getTreePathOfNode(liveNode);\n\n    staticNode.removeAttribute(this.options.referenceAttribute);\n\n    traverseNode(liveNode, (lNode, path) => {\n      if (!isElementNode(lNode)) return;\n\n      path.splice(0, rootPath.length, 0);\n\n      const sNode = getNodeByTreePath(staticNode, path);\n      const id = lNode.getAttribute(this.options.referenceAttribute);\n\n      if (id) {\n        this.saveReference(lNode, sNode, id);\n      } else {\n        this.saveReference(lNode, sNode);\n      }\n\n      this.options.forEachReferenceSave(lNode, sNode);\n    }, true);\n\n    return staticNode;\n  }\n\n  composeLiveReference(staticNode) {\n    if (!isDocumentNode(staticNode) && !isElementNode(staticNode)) {\n      throw new TypeError('staticNode is not neither Document nor Element');\n    }\n\n    const staticRoot = isDocumentNode(staticNode) ? staticNode : staticNode.ownerDocument;\n    const liveNode = staticNode.cloneNode(true);\n\n    traverseNode(liveNode, (lNode, path) => {\n      if (!isElementNode(lNode)) return;\n\n      const sNode = getNodeByTreePath(staticRoot, path);\n      const id = lNode.getAttribute(this.options.referenceAttribute);\n\n      if (id) {\n        this.saveReference(lNode, sNode, id);\n      } else {\n        this.saveReference(lNode, sNode);\n      }\n\n      this.options.forEachReferenceSave(lNode, sNode);\n    }, true);\n\n    return liveNode;\n  }\n\n  isReferenceId(id) {\n    return Object.prototype.hasOwnProperty.call(this.map, id);\n  }\n\n  getReferenceId(liveNode) {\n    if (!isElementNode(liveNode)) return undefined;\n    return liveNode.getAttribute(this.options.referenceAttribute);\n  }\n\n  getPreviousReferenceId(liveNode) {\n    let referenceId;\n    let node = liveNode.previousElementSibling;\n    while (node) {\n      referenceId = this.getReferenceId(node);\n      if (referenceId) break;\n      node = node.previousElementSibling;\n    }\n\n    return referenceId;\n  }\n\n  getNextReferenceId(liveNode) {\n    let referenceId;\n    let node = liveNode.nextElementSibling;\n    while (node) {\n      referenceId = this.getReferenceId(node);\n      if (referenceId) break;\n      node = node.nextElementSibling;\n    }\n\n    return referenceId;\n  }\n\n  getParentReferenceId(liveNode) {\n    let referenceId;\n    let node = liveNode.parentElement;\n    while (node) {\n      referenceId = this.getReferenceId(node);\n      if (referenceId) break;\n      node = node.parentElement;\n    }\n\n    return referenceId;\n  }\n\n  getFirstChildReferenceId(liveNode) {\n    let referenceId;\n    let node = liveNode.firstElementChild;\n    while (node) {\n      referenceId = this.getReferenceId(node);\n      if (referenceId) break;\n      node = node.nextElementSibling;\n    }\n\n    return referenceId;\n  }\n\n  getLastChildReferenceId(liveNode) {\n    let referenceId;\n    let node = liveNode.lastElementChild;\n    while (node) {\n      referenceId = this.getReferenceId(node);\n      if (referenceId) break;\n      node = node.previousElementSibling;\n    }\n\n    return referenceId;\n  }\n\n  getChildReferenceId(liveNode, childIndex) {\n    let referenceId;\n    let index = 0;\n    let node = liveNode.firstElementChild;\n    while (node) {\n      if (this.hasReference(node)) {\n        if (index === childIndex) {\n          referenceId = this.getReferenceId(node);\n          break;\n        }\n\n        index += 1;\n      }\n      node = node.nextElementSibling;\n    }\n\n    return referenceId;\n  }\n\n  indexOfReferenceId(liveNode, referenceId) {\n    let node = liveNode.firstElementChild;\n    while (node) {\n      if (node.getAttribute(this.options.referenceAttribute) === referenceId) {\n        const staticNode = this.getReferenceById(referenceId);\n        const nodesList = Array.prototype.slice.call(staticNode.parentNode.childNodes);\n        return nodesList.indexOf(staticNode);\n      }\n      node = node.nextElementSibling;\n    }\n\n    return -1;\n  }\n\n  hasReference(liveNode) {\n    return this.isReferenceId(this.getReferenceId(liveNode));\n  }\n\n  getReference(liveNode) {\n    const id = this.getReferenceId(liveNode);\n    return this.getReferenceById(id);\n  }\n\n  getReferenceById(id) {\n    if (!this.isReferenceId(id)) return undefined;\n    return this.map[id].staticNode;\n  }\n\n  setReferenceAttribute(id, attr, value) {\n    if (!this.isReferenceId(id)) {\n      throw new ReferenceError('reference with specified id is not found');\n    }\n\n    const { staticNode } = this.map[id];\n    staticNode.setAttribute(attr, value);\n  }\n\n  hasReferenceAttribute(id, attr) {\n    if (!this.isReferenceId(id)) {\n      throw new ReferenceError('reference with specified id is not found');\n    }\n\n    const { staticNode } = this.map[id];\n    return staticNode.hasAttribute(attr);\n  }\n\n  removeReferenceAttribute(id, attr) {\n    if (!this.isReferenceId(id)) {\n      throw new ReferenceError('reference with specified id is not found');\n    }\n\n    const { staticNode } = this.map[id];\n    staticNode.removeAttribute(attr);\n  }\n\n  removeReference(id) {\n    if (!this.isReferenceId(id)) {\n      throw new ReferenceError('reference with specified id is not found');\n    }\n\n    const { staticNode } = this.map[id];\n    staticNode.parentNode.removeChild(staticNode);\n    delete this.map[id];\n\n    return staticNode;\n  }\n\n  appendReference(liveNode, containerId) {\n    if (!this.isReferenceId(containerId)) {\n      throw new ReferenceError('reference with specified containerId is not found');\n    }\n\n    const staticContainer = this.map[containerId].staticNode;\n    const staticNode = this.composeStaticReference(liveNode);\n\n    staticContainer.appendChild(staticNode);\n\n    return staticNode;\n  }\n\n  insertReference(liveNode, refElementId, position) {\n    if (!this.isReferenceId(refElementId)) {\n      throw new ReferenceError('reference with specified refElementId is not found');\n    }\n\n    const refElement = this.map[refElementId].staticNode;\n    const staticNode = this.composeStaticReference(liveNode);\n\n    refElement.insertAdjacentElement(position, staticNode);\n\n    return staticNode;\n  }\n\n  replaceReference(liveNode, referenceId) {\n    if (!this.isReferenceId(referenceId)) {\n      throw new ReferenceError('reference with specified referenceId is not found');\n    }\n\n    const oldStaticElement = this.map[referenceId].staticNode;\n    const newStaticElement = this.composeStaticReference(liveNode, referenceId);\n\n    oldStaticElement.parentNode.replaceChild(newStaticElement, oldStaticElement);\n\n    return newStaticElement;\n  }\n\n  flush() {\n    Object.keys(this.map).forEach((id) => {\n      const { staticNode } = this.map[id];\n      let node = staticNode;\n\n      while (node && !isDocumentNode(node)) {\n        if (!node.parentNode) {\n          delete this.map[id];\n          return;\n        }\n        node = node.parentNode;\n      }\n    });\n  }\n\n  unbind(liveNode) {\n    if (!isElementNode(liveNode)) return;\n    liveNode.removeAttribute(this.options.referenceAttribute);\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/reference-map.js"],"sourceRoot":""}