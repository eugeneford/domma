{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 0992e972b4ac64e32e3e","webpack:///external \"anodum\"","webpack:///./src/domma.js","webpack:///./src/mutation-driver.js","webpack:///./src/mutation-types.js","webpack:///./src/reference-map.js"],"names":["Domma","options","config","childList","attributes","attributeOldValue","characterData","characterDataOldValue","subtree","reset","staticDOM","driver","connectStaticDocument","referenceMap","getStaticDocument","ReferenceError","liveDOM","composeLiveReference","connectLiveDocument","mutationObserver","disconnect","observe","getLiveDocument","transactionStatus","transaction","Promise","resolve","reject","then","transactionObserver","MutationObserver","conductTransaction","mutationEmitter","mutations","isTransactionPending","getLastTransaction","addAdditiveMutations","MutationDriver","onBeforeSync","onAfterSync","additiveMutations","lastTransaction","undefined","bind","conductMutation","reduceAdditiveMutations","TypeError","liveElement","containerNode","getReference","unbind","mutation","attributeName","oldValue","containerId","getReferenceId","setReferenceAttribute","removeReferenceAttribute","addedNodes","removedNodes","nextLiveSibling","nextSibling","length","previousSibling","node","nextStaticSibling","parentNode","liveNodes","Array","prototype","slice","call","childNodes","liveIndex","indexOf","prevLiveSibling","prevStaticSibling","forEach","addedLiveNode","id","removeReference","staticNode","firstChild","removeChild","removedLiveNode","cloneNode","textMutations","getAdditiveMutations","textMutation","nodeValue","insertBefore","appendChild","lNode","ejectAdditiveReferenceMapMutations","reverse","type","ejectAdditiveAttributeMutation","ejectAdditiveChildListMutation","concat","liveNode","types","all","index","splice","filter","sameTarget","target","validType","reference","referenceId","attribute","hasAttribute","value","getAttribute","newReference","replaceReference","ejectAdditiveMutations","flush","hasReference","conductAttributeMutation","conductCharacterDataMutation","conductChildListMutation","ReferenceMap","referenceAttribute","forEachReferenceSave","map","referenceCounter","staticDocument","setAttribute","importNode","rootPath","removeAttribute","path","sNode","saveReference","staticRoot","ownerDocument","Object","hasOwnProperty","previousElementSibling","nextElementSibling","parentElement","firstElementChild","lastElementChild","isReferenceId","getReferenceById","attr","staticContainer","composeStaticReference","siblingId","siblingNode","oldStaticElement","newStaticElement","replaceChild","keys"],"mappings":"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","file":"./dist/domma.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"anodum\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"anodum\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"domma\"] = factory(require(\"anodum\"));\n\telse\n\t\troot[\"domma\"] = factory(root[\"anodum\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 0992e972b4ac64e32e3e","module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"anodum\"\n// module id = 0\n// module chunks = 0","import MutationDriver from './mutation-driver';\n\nexport default class Domma {\n  constructor(options) {\n    this.options = options;\n    this.config = {\n      childList: true,\n      attributes: true,\n      attributeOldValue: true,\n      characterData: true,\n      characterDataOldValue: true,\n      subtree: true,\n    };\n\n    this.reset();\n  }\n\n  connectStaticDocument(staticDOM) {\n    this.driver.connectStaticDocument(staticDOM);\n    this.driver.referenceMap.connectStaticDocument(staticDOM);\n  }\n\n  composeLiveDocument() {\n    const staticDOM = this.driver.getStaticDocument();\n\n    if (!staticDOM) {\n      throw new ReferenceError('static document is not connected');\n    }\n\n    const liveDOM = this.driver.referenceMap.composeLiveReference(staticDOM);\n\n    this.connectLiveDocument(liveDOM);\n  }\n\n  connectLiveDocument(liveDOM) {\n    this.mutationObserver.disconnect();\n    this.driver.connectLiveDocument(liveDOM);\n    this.mutationObserver.observe(liveDOM, this.config);\n  }\n\n  getStaticDocument() {\n    return this.driver.getStaticDocument();\n  }\n\n  getLiveDocument() {\n    return this.driver.getLiveDocument();\n  }\n\n  isTransactionResolved() {\n    return this.transactionStatus === 'resolved';\n  }\n\n  isTransactionPending() {\n    return this.transactionStatus === 'pending';\n  }\n\n  conductTransaction(transaction) {\n    return new Promise((resolve, reject) => {\n      const liveDOM = this.driver.getLiveDocument();\n      if (!liveDOM) reject(new ReferenceError('live document is not connected'));\n      resolve(liveDOM);\n    }).then(liveDOM => new Promise((resolve) => {\n      this.transactionStatus = 'pending';\n      this.resolve = resolve;\n      transaction(liveDOM);\n    }));\n  }\n\n  reset() {\n    if (this.transactionObserver) this.transactionObserver.disconnect();\n    if (this.mutationObserver) this.mutationObserver.disconnect();\n\n    this.driver = new MutationDriver(this.options);\n    this.transactionStatus = 'resolved';\n    this.transactionObserver = new MutationObserver(this.driver.conductTransaction);\n    this.mutationEmitter = (mutations) => {\n      if (this.isTransactionPending()) {\n        this.driver.conductTransaction(mutations);\n        this.transactionStatus = 'resolved';\n        this.resolve(this.driver.getLastTransaction());\n      } else {\n        this.driver.addAdditiveMutations(mutations);\n      }\n    };\n    this.mutationObserver = new MutationObserver(this.mutationEmitter);\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/domma.js","import {\n  isDocumentNode,\n  isElementNode,\n  traverseNode,\n} from 'anodum';\n\nimport mutationTypes from './mutation-types';\nimport ReferenceMap from './reference-map';\n\nexport default class MutationDriver {\n  constructor(options) {\n    this.options = {\n      onBeforeSync: () => {\n      },\n      onAfterSync: () => {\n      },\n      ...options,\n    };\n    this.additiveMutations = [];\n    this.lastTransaction = undefined;\n    this.referenceMap = new ReferenceMap(options);\n\n    this.conductTransaction = this.conductTransaction.bind(this);\n    this.conductMutation = this.conductMutation.bind(this);\n    this.reduceAdditiveMutations = this.reduceAdditiveMutations.bind(this);\n  }\n\n  connectStaticDocument(staticDOM) {\n    if (!isDocumentNode(staticDOM)) {\n      throw new TypeError('staticDOM is not a Document');\n    }\n\n    this.staticDOM = staticDOM;\n  }\n\n  connectLiveDocument(liveDOM) {\n    if (!isDocumentNode(liveDOM)) {\n      throw new TypeError('liveDOM is not a Document');\n    }\n\n    this.liveDOM = liveDOM;\n  }\n\n  getStaticDocument() {\n    return this.staticDOM;\n  }\n\n  getLiveDocument() {\n    return this.liveDOM;\n  }\n\n  ejectAdditiveReferenceMapMutations(liveElement) {\n    const containerNode = this.referenceMap.getReference(liveElement);\n    this.referenceMap.unbind(containerNode);\n  }\n\n  ejectAdditiveAttributeMutation(liveElement, mutation) {\n    const { attributeName, oldValue } = mutation;\n    const containerId = this.referenceMap.getReferenceId(liveElement);\n\n    if (oldValue) {\n      this.referenceMap.setReferenceAttribute(containerId, attributeName, oldValue);\n    } else {\n      this.referenceMap.removeReferenceAttribute(containerId, attributeName);\n    }\n  }\n\n  ejectAdditiveChildListMutation(liveElement, mutation) {\n    const containerNode = this.referenceMap.getReference(liveElement);\n    const {\n      addedNodes,\n      removedNodes,\n    } = mutation;\n\n    let nextLiveSibling = mutation.nextSibling;\n    if (removedNodes.length && addedNodes.length) {\n      nextLiveSibling = addedNodes[addedNodes.length - 1].nextSibling;\n    } else if (removedNodes.length) {\n      const { previousSibling, nextSibling } = mutation;\n      let node = nextSibling;\n      while (node) {\n        if (previousSibling === node.previousSibling) {\n          nextLiveSibling = node;\n          break;\n        }\n        node = node.previousSibling;\n      }\n    }\n\n    let nextStaticSibling;\n    if (nextLiveSibling && nextLiveSibling.parentNode) {\n      const liveNodes = Array.prototype.slice.call(nextLiveSibling.parentNode.childNodes);\n      const liveIndex = liveNodes.indexOf(nextLiveSibling);\n      nextStaticSibling = containerNode.childNodes[liveIndex];\n    }\n\n    const prevLiveSibling = mutation.previousSibling;\n\n    let prevStaticSibling;\n    if (prevLiveSibling && prevLiveSibling.parentNode) {\n      const liveNodes = Array.prototype.slice.call(prevLiveSibling.parentNode.childNodes);\n      const liveIndex = liveNodes.indexOf(prevLiveSibling);\n      prevStaticSibling = containerNode.childNodes[liveIndex];\n    }\n\n    addedNodes.forEach((addedLiveNode) => {\n      if (isElementNode(addedLiveNode)) {\n        const id = this.referenceMap.getReferenceId(addedLiveNode);\n        this.referenceMap.removeReference(id);\n        this.referenceMap.unbind(addedLiveNode);\n        this.reduceAdditiveMutations(addedLiveNode);\n      } else {\n        let staticNode;\n        if (nextStaticSibling) {\n          staticNode = nextStaticSibling.previousSibling;\n        } else if (prevStaticSibling && prevStaticSibling.nextSibling) {\n          staticNode = prevStaticSibling.nextSibling;\n        } else {\n          staticNode = containerNode.firstChild;\n        }\n        containerNode.removeChild(staticNode);\n      }\n    });\n\n    removedNodes.forEach((removedLiveNode) => {\n      let staticNode;\n      if (isElementNode(removedLiveNode)) {\n        staticNode = this.referenceMap.getReference(removedLiveNode);\n      } else {\n        staticNode = removedLiveNode.cloneNode();\n        const textMutations = this.getAdditiveMutations(removedLiveNode);\n        textMutations.forEach((textMutation) => {\n          staticNode.nodeValue = textMutation.oldValue;\n        });\n      }\n\n      if (nextStaticSibling) {\n        containerNode.insertBefore(staticNode, nextStaticSibling);\n      } else if (prevStaticSibling && prevStaticSibling.nextSibling) {\n        containerNode.insertBefore(staticNode, prevStaticSibling.nextSibling);\n      } else {\n        containerNode.appendChild(staticNode);\n      }\n    });\n  }\n\n  ejectAdditiveMutations(liveElement) {\n    traverseNode(liveElement, (lNode) => {\n      const mutations = this.getAdditiveMutations(lNode);\n\n      this.ejectAdditiveReferenceMapMutations(lNode);\n\n      mutations.reverse().forEach((mutation) => {\n        switch (mutation.type) {\n          case mutationTypes.attributes:\n            this.ejectAdditiveAttributeMutation(lNode, mutation);\n            break;\n          default:\n            this.ejectAdditiveChildListMutation(lNode, mutation);\n            break;\n        }\n      });\n    });\n  }\n\n  addAdditiveMutations(mutations) {\n    this.additiveMutations = this.additiveMutations.concat(mutations);\n  }\n\n  reduceAdditiveMutations(liveNode, types = mutationTypes.all) {\n    const additiveMutations = this.getAdditiveMutations(liveNode, types);\n\n    additiveMutations.forEach((mutation) => {\n      const index = this.additiveMutations.indexOf(mutation);\n      this.additiveMutations.splice(index, 1);\n      mutation.addedNodes.forEach(node => this.reduceAdditiveMutations(node));\n      mutation.removedNodes.forEach(node => this.reduceAdditiveMutations(node));\n    });\n  }\n\n  getAdditiveMutations(liveNode, types = mutationTypes.all) {\n    return this.additiveMutations.filter((mutation) => {\n      const sameTarget = mutation.target === liveNode;\n      const validType = types.indexOf(mutation.type) > -1;\n      return sameTarget && validType;\n    });\n  }\n\n  conductAttributeMutation(mutation) {\n    const liveNode = mutation.target;\n    const reference = this.referenceMap.getReference(liveNode);\n    const referenceId = this.referenceMap.getReferenceId(liveNode);\n    const attribute = mutation.attributeName;\n\n    this.options.onBeforeSync(reference);\n    if (liveNode.hasAttribute(attribute)) {\n      const value = liveNode.getAttribute(attribute);\n      this.referenceMap.setReferenceAttribute(referenceId, attribute, value);\n    } else {\n      this.referenceMap.removeReferenceAttribute(referenceId, attribute);\n    }\n    this.options.onAfterSync(reference);\n  }\n\n  conductCharacterDataMutation(mutation) {\n    const liveNode = mutation.target.parentNode;\n    const reference = this.referenceMap.getReference(liveNode);\n    const referenceId = this.referenceMap.getReferenceId(liveNode);\n    this.reduceAdditiveMutations(mutation.target, [mutationTypes.characterData]);\n    this.options.onBeforeSync(reference);\n    const newReference = this.referenceMap.replaceReference(liveNode, referenceId);\n    this.ejectAdditiveMutations(liveNode);\n    this.referenceMap.flush();\n    this.options.onAfterSync(newReference);\n  }\n\n  conductChildListMutation(mutation) {\n    const liveNode = mutation.target;\n    const reference = this.referenceMap.getReference(liveNode);\n    const referenceId = this.referenceMap.getReferenceId(liveNode);\n    const {\n      addedNodes,\n      removedNodes,\n      nextSibling,\n      previousSibling,\n    } = mutation;\n\n    // for target.innerHTML or target.replacedChild\n    if (addedNodes.length && removedNodes.length && !nextSibling && !previousSibling) {\n      this.reduceAdditiveMutations(liveNode, [mutationTypes.childList]);\n    }\n\n    this.options.onBeforeSync(reference);\n    const newReference = this.referenceMap.replaceReference(liveNode, referenceId);\n    this.ejectAdditiveMutations(liveNode);\n    this.referenceMap.flush();\n    this.options.onAfterSync(newReference);\n  }\n\n  conductMutation(mutation) {\n    switch (mutation.type) {\n      case mutationTypes.attributes:\n        if (!this.referenceMap.hasReference(mutation.target)) return;\n        this.conductAttributeMutation(mutation);\n        break;\n      case mutationTypes.characterData:\n        if (!this.referenceMap.hasReference(mutation.target.parentNode)) return;\n        this.conductCharacterDataMutation(mutation);\n        break;\n      default:\n        if (!this.referenceMap.hasReference(mutation.target)) return;\n        this.conductChildListMutation(mutation);\n        break;\n    }\n  }\n\n  conductTransaction(mutations) {\n    const transaction = mutations;\n    transaction.forEach(this.conductMutation);\n    this.lastTransaction = transaction;\n  }\n\n  getLastTransaction() {\n    return this.lastTransaction;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/mutation-driver.js","export default {\n  all: ['childList', 'attributes', 'characterData'],\n  characterData: 'characterData',\n  attributes: 'attributes',\n  childList: 'childList',\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/mutation-types.js","import {\n  getNodeByTreePath,\n  getTreePathOfNode,\n  isDocumentNode,\n  isElementNode,\n  traverseNode,\n} from 'anodum';\n\n\nexport default class ReferenceMap {\n  constructor(options) {\n    this.options = {\n      referenceAttribute: 'data-uuid',\n      forEachReferenceSave: () => {\n      },\n      ...options,\n    };\n    this.map = {};\n    this.referenceCounter = 1;\n  }\n\n  connectStaticDocument(staticDocument) {\n    this.staticDocument = staticDocument;\n  }\n\n  saveReference(liveNode, staticNode, id) {\n    const referenceId = id || `ref_${this.referenceCounter}`;\n\n    if (liveNode.getAttribute(this.options.referenceAttribute) !== referenceId) {\n      liveNode.setAttribute(this.options.referenceAttribute, referenceId);\n    }\n\n    this.map[referenceId] = { staticNode };\n    this.referenceCounter += 1;\n    return referenceId;\n  }\n\n  composeStaticReference(liveNode) {\n    if (!isDocumentNode(liveNode) && !isElementNode(liveNode)) {\n      throw new TypeError('liveNode is not neither Document nor Element');\n    }\n\n    if (!this.staticDocument) {\n      throw new ReferenceError('static document is not connected');\n    }\n\n    const staticDOM = this.staticDocument;\n    const staticNode = staticDOM.importNode(liveNode, true);\n    const rootPath = getTreePathOfNode(liveNode);\n\n    staticNode.removeAttribute(this.options.referenceAttribute);\n\n    traverseNode(liveNode, (lNode, path) => {\n      if (!isElementNode(lNode)) return;\n\n      path.splice(0, rootPath.length, 0);\n\n      const sNode = getNodeByTreePath(staticNode, path);\n      const id = lNode.getAttribute(this.options.referenceAttribute);\n\n      if (id) {\n        this.saveReference(lNode, sNode, id);\n      } else {\n        this.saveReference(lNode, sNode);\n      }\n\n      this.options.forEachReferenceSave(lNode, sNode);\n    }, true);\n\n    return staticNode;\n  }\n\n  composeLiveReference(staticNode) {\n    if (!isDocumentNode(staticNode) && !isElementNode(staticNode)) {\n      throw new TypeError('staticNode is not neither Document nor Element');\n    }\n\n    const staticRoot = isDocumentNode(staticNode) ? staticNode : staticNode.ownerDocument;\n    const liveNode = staticNode.cloneNode(true);\n\n    traverseNode(liveNode, (lNode, path) => {\n      if (!isElementNode(lNode)) return;\n\n      const sNode = getNodeByTreePath(staticRoot, path);\n      const id = lNode.getAttribute(this.options.referenceAttribute);\n\n      if (id) {\n        this.saveReference(lNode, sNode, id);\n      } else {\n        this.saveReference(lNode, sNode);\n      }\n\n      this.options.forEachReferenceSave(lNode, sNode);\n    }, true);\n\n    return liveNode;\n  }\n\n  isReferenceId(id) {\n    return Object.prototype.hasOwnProperty.call(this.map, id);\n  }\n\n  getReferenceId(liveNode) {\n    if (!isElementNode(liveNode)) return undefined;\n    return liveNode.getAttribute(this.options.referenceAttribute);\n  }\n\n  getPreviousReferenceId(liveNode) {\n    let referenceId;\n    let node = liveNode.previousElementSibling;\n    while (node) {\n      referenceId = this.getReferenceId(node);\n      if (referenceId) break;\n      node = node.previousElementSibling;\n    }\n\n    return referenceId;\n  }\n\n  getNextReferenceId(liveNode) {\n    let referenceId;\n    let node = liveNode.nextElementSibling;\n    while (node) {\n      referenceId = this.getReferenceId(node);\n      if (referenceId) break;\n      node = node.nextElementSibling;\n    }\n\n    return referenceId;\n  }\n\n  getParentReferenceId(liveNode) {\n    let referenceId;\n    let node = liveNode.parentElement;\n    while (node) {\n      referenceId = this.getReferenceId(node);\n      if (referenceId) break;\n      node = node.parentElement;\n    }\n\n    return referenceId;\n  }\n\n  getFirstChildReferenceId(liveNode) {\n    let referenceId;\n    let node = liveNode.firstElementChild;\n    while (node) {\n      referenceId = this.getReferenceId(node);\n      if (referenceId) break;\n      node = node.nextElementSibling;\n    }\n\n    return referenceId;\n  }\n\n  getLastChildReferenceId(liveNode) {\n    let referenceId;\n    let node = liveNode.lastElementChild;\n    while (node) {\n      referenceId = this.getReferenceId(node);\n      if (referenceId) break;\n      node = node.previousElementSibling;\n    }\n\n    return referenceId;\n  }\n\n  hasReference(liveNode) {\n    return this.isReferenceId(this.getReferenceId(liveNode));\n  }\n\n  getReference(liveNode) {\n    const id = this.getReferenceId(liveNode);\n    return this.getReferenceById(id);\n  }\n\n  getReferenceById(id) {\n    if (!this.isReferenceId(id)) return undefined;\n    return this.map[id].staticNode;\n  }\n\n  setReferenceAttribute(id, attr, value) {\n    if (!this.isReferenceId(id)) {\n      throw new ReferenceError('reference with specified id is not found');\n    }\n\n    const { staticNode } = this.map[id];\n    staticNode.setAttribute(attr, value);\n  }\n\n  hasReferenceAttribute(id, attr) {\n    if (!this.isReferenceId(id)) {\n      throw new ReferenceError('reference with specified id is not found');\n    }\n\n    const { staticNode } = this.map[id];\n    return staticNode.hasAttribute(attr);\n  }\n\n  removeReferenceAttribute(id, attr) {\n    if (!this.isReferenceId(id)) {\n      throw new ReferenceError('reference with specified id is not found');\n    }\n\n    const { staticNode } = this.map[id];\n    staticNode.removeAttribute(attr);\n  }\n\n  removeReference(id) {\n    if (!this.isReferenceId(id)) {\n      throw new ReferenceError('reference with specified id is not found');\n    }\n\n    const { staticNode } = this.map[id];\n    staticNode.parentNode.removeChild(staticNode);\n    delete this.map[id];\n\n    return staticNode;\n  }\n\n  appendReference(liveNode, containerId) {\n    if (!this.isReferenceId(containerId)) {\n      throw new ReferenceError('reference with specified containerId is not found');\n    }\n\n    const staticContainer = this.map[containerId].staticNode;\n    const staticNode = this.composeStaticReference(liveNode);\n\n    staticContainer.appendChild(staticNode);\n\n    return staticNode;\n  }\n\n  insertReferenceBefore(liveNode, siblingId) {\n    if (!this.isReferenceId(siblingId)) {\n      throw new ReferenceError('reference with specified siblingId is not found');\n    }\n\n    const siblingNode = this.map[siblingId].staticNode;\n    const staticNode = this.composeStaticReference(liveNode);\n\n    siblingNode.parentNode.insertBefore(staticNode, siblingNode);\n\n    return staticNode;\n  }\n\n  replaceReference(liveNode, referenceId) {\n    if (!this.isReferenceId(referenceId)) {\n      throw new ReferenceError('reference with specified referenceId is not found');\n    }\n\n    const oldStaticElement = this.map[referenceId].staticNode;\n    const newStaticElement = this.composeStaticReference(liveNode, referenceId);\n\n    oldStaticElement.parentNode.replaceChild(newStaticElement, oldStaticElement);\n\n    return newStaticElement;\n  }\n\n  flush() {\n    Object.keys(this.map).forEach((id) => {\n      const { staticNode } = this.map[id];\n      let node = staticNode;\n\n      while (node && !isDocumentNode(node)) {\n        if (!node.parentNode) {\n          delete this.map[id];\n          return;\n        }\n        node = node.parentNode;\n      }\n    });\n  }\n\n  unbind(liveNode) {\n    if (!isElementNode(liveNode)) return;\n    liveNode.removeAttribute(this.options.referenceAttribute);\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/reference-map.js"],"sourceRoot":""}